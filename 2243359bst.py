# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uJTDJzDVNwCeREBTFvrUu9hTrrPWR6XQ
"""

class Node:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None

class BinarySearchTree:
    def __init__(self):
        self.root = None

    def insert(self, key):
        if self.root is None:
            self.root = Node(key)
        else:
            self._insert(self.root, key)

    def _insert(self, current, key):
        if key < current.key:
            if current.left is None:
                current.left = Node(key)
            else:
                self._insert(current.left, key)
        else:
            if current.right is None:
                current.right = Node(key)
            else:
                self._insert(current.right, key)

    def search(self, key):
        return self._search(self.root, key, "R")

    def _search(self, current, key, path):
        if current is None:
            return None
        if current.key == key:
            return path
        elif key < current.key:
            return self._search(current.left, key, path + "0")
        else:
            return self._search(current.right, key, path + "1")

    def delete(self, key):
        self.root = self._delete(self.root, key)

    def _delete(self, current, key):
        if current is None:
            return current
        if key < current.key:
            current.left = self._delete(current.left, key)
        elif key > current.key:
            current.right = self._delete(current.right, key)
        else:
            if current.left is None:
                return current.right
            elif current.right is None:
                return current.left


            min_larger_node = self._find_min(current.right)
            current.key = min_larger_node.key
            current.right = self._delete(current.right, min_larger_node.key)

        return current

    def _find_min(self, current):
        while current.left is not None:
            current = current.left
        return current

def process_input_file(input_file):
    with open(input_file, 'r') as file:
        lines = file.readlines()

    t = int(lines[0].strip())
    results = []

    idx = 1
    for _ in range(t):
        bst = BinarySearchTree()

        i = int(lines[idx].strip())
        idx += 1
        keys_to_insert = list(map(int, lines[idx].strip().split()))
        idx += 1

        for key in keys_to_insert:
            bst.insert(key)

        s1 = int(lines[idx].strip())
        idx += 1
        keys_to_search = list(map(int, lines[idx].strip().split()))
        idx += 1

        for key in keys_to_search:
            results.append(bst.search(key))

        d = int(lines[idx].strip())
        idx += 1
        keys_to_delete = list(map(int, lines[idx].strip().split()))
        idx += 1

        for key in keys_to_delete:
            bst.delete(key)

        s2 = int(lines[idx].strip())
        idx += 1
        keys_to_search = list(map(int, lines[idx].strip().split()))
        idx += 1

        for key in keys_to_search:
            results.append(bst.search(key))

    return results

def write_output_file(output_file, results):
    with open(output_file, 'w') as file:
        for result in results:
            file.write(result + '\n')

if __name__ == "__main__":
    input_file = "bst_input.txt"
    output_file = "bst_output.txt"

    results = process_input_file(input_file)
    write_output_file(output_file, results)